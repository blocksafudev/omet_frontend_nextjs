{"status":"1","result":[{"SourceCode":"// SPDX-License-Identifier: MIXED\n\n// File contracts/AMM/ISatoshiSwapFactory.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function INIT_CODE_PAIR_HASH() external pure returns (bytes32);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function isPair(address) external view returns (bool);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function initialize(address _core, address _feeToSetter) external;\n    function setFeeToSetter(address) external;\n}\n\n// File contracts/AMM/ISatoshiSwapCore.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapCore {\n    /**\n     * @notice Type of pair\n     * @dev currently supported: Volatile, Stable\n     * @dev Volatile: Uniswap V2 style pair that supports x * y >= k\n     * @dev Stable: Solidly style stableswap pair using x3y + y3x >= k\n     */\n    enum PairType {\n        Volatile,\n        Stable\n    }\n\n    event Initialized(address factory, address WETH, address stable, address ethStablePair);\n    event NewToken(address token, string name, string symbol, uint decimals);\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    event Mint(address indexed pair, address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed pair, address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed pair,\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event TransferLP(address indexed pair, address indexed from, address indexed to, uint value);\n    event Sync(\n        address indexed pair,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint price0,\n        uint price1,\n        uint price0Eth,\n        uint price1Eth,\n        uint ethPrice\n    );\n    event UpdatePairType(address indexed pair, PairType indexed pairType);\n    event UpdateFeePoint(uint indexed feePoint);\n    event UpdateTokenFeePoint(address indexed pairAddress, address indexed tokenAddress, uint indexed feePoint);\n    event UpdateStable(address indexed stable);\n\n    /**\n     * @dev Initialize contract\n     */\n    function initialize(address _factory, address _router, address _feeToSetter, address _WETH, address _stable, bool _init) external;\n\n    /**\n     * @dev Storage view function\n     */\n    /// @dev Swap factory address (creates LP pair token)\n    function factory() external view returns (address factoryAddress);\n    /// @dev Fee controller & core controller address\n    function feeToSetter() external view returns (address feeToSetter);\n    /// @dev Vault controller address\n    function vaultController() external view returns (address vaultController);\n    /// @dev WETH contract address\n    function WETH() external view returns (address WETH);\n    /// @dev Stable token contract address (used for price view)\n    function Stable() external view returns (address stable);\n\n    /// @dev ethPrice (WETH quoted by stable)\n    function ethPrice() external view returns (uint ethPrice);\n    /// @dev ethStablePair to get the ethPrice from\n    function ethStablePair() external view returns (address ethStablePair);\n    /// @dev Fee point in Basis Points\n    function feePoint() external view returns (uint feePoint);\n\n    /**\n     * @dev Functions only called by Factory\n     */\n    /// @dev Push new pair info to SatoshiSwapCore contract\n    function initPair(address _pair, address _token0, address _token1) external;\n\n    /**\n     * @dev (Write-only) Functions only called by Pair\n     */\n    /// @dev mint function called by pair contract\n    function mint(uint totalSupply) external returns (uint liquidity, uint amount0, uint amount1);\n    /// @dev Emit mint event for core contract\n    function emitMint(address msgSender, uint amount0, uint amount1) external;\n    /// @dev burn function called by pair contract\n    function burn(address to, uint liquidity, uint totalSupply) external returns (uint amount0, uint amount1);\n    /// @dev Emit burn event for core contract\n    function emitBurn(address msgSender, uint amount0, uint amount1, address to) external;\n    /// @dev swap function called by pair contract\n    function swap(address msgSender, uint amount0Out, uint amount1Out, address to, bytes calldata data) external returns (uint amount0In, uint amount1In);\n    /// @dev Emit swap event for core contract\n    function emitSwap(address sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address to) external;\n    /// @dev Emit LP token transfer event for syncing subgraph\n    function emitTransfer(address from, address to, uint value) external;\n    /// @dev skim function called by pair contract\n    function skim(address pairAddress, address to) external;\n    /// @dev sync function called by pair contract\n    function sync(address pairAddress) external;\n\n    /**\n     * @dev (Read-only) Functions only called by Pair\n     */\n    /// @dev get pair fees\n    function getFees(address pairAddress) external view returns (uint feePoint, uint token0fee, uint token1fee);\n    /// @dev Get type of pair\n    function getPairType(address pairAddress) external view returns (PairType);\n\n    /**\n     * @dev Functions commonly called by Pair & Router\n     */\n    /// @dev fetches cumulative price\n    function getCumulativePrice(address pairAddress) external view returns (uint price0CumulativeLast, uint price1CumulativeLast);\n    /// @dev get kLast\n    function getKlast(address pairAddress) external view returns (uint kLast);\n    /// @dev fetches and sorts the reserves for a pair\n    function getReserves(address pairAddress) external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    /**\n     * @dev Functions called by Router\n     */\n    /// @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint);\n    /// @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, address tokenIn, address tokenOut) external view returns (uint);\n    /// @dev performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    /// @dev performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n\n    /**\n     * @dev View only functions\n     */\n    /// @dev Get pair address\n    function getPair(address tokenA, address tokenB) external view returns (address pairAddress);\n    /// @dev Get pair info\n    function getPairTokens(address pairAddress) external view returns (address token0, address token1);\n    /// @dev Get length of pair in storage\n    function getPairLength() external view returns (uint);\n    /// @dev Get encoded rates multiplied by 1e18\n    function getEncodedRates(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get effective rates of the pair\n    function getEffectiveRates(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get static effective price of the pair\n    function getEffectivePrices(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get static prices of the pair\n    function getPairPrices(address pairAddress) external view returns (uint price0, uint price1, uint price0Eth, uint price1Eth);\n    /// @dev Get every tracking tokens registered\n    function getTracking() external view returns (address[] memory);\n    /// @dev Get every blacklisted pairs registered\n    function getBlacklisted() external view returns (address[] memory);\n}\n\n// File contracts/AMM/ISatoshiSwapPair.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapPair {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function getPairInfo() external view returns (\n        ISatoshiSwapCore.PairType pairType,\n        address tokenA,\n        address tokenB,\n        uint feePoint,\n        uint tokenAfee,\n        uint tokenBfee,\n        uint decimalsA,\n        uint decimalsB,\n        uint112 reserveA,\n        uint112 reserveB,\n        uint blockTimestampLast\n    );\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address _core, address _token0, address _token1) external;\n    function checkVault(address _vaultController) external;\n}\n\n// File contracts/AMM/SatoshiSwapFactory.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract SatoshiSwapERC20 is IERC20 {\n    string private _name = 'SatoshiSwap LP';\n    string private _symbol = 'Satoshi-LP';\n    uint8 private _decimals = 18;\n    uint private _totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    bytes32 internal _DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) private _nonces;\n\n    ISatoshiSwapCore private core;\n\n    function updateDomainSeparator() internal {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(_name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function setCoreInternal(ISatoshiSwapCore _core) internal {\n        core = _core;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n\n    function nonces(address owner) public view virtual returns (uint) {\n        return _nonces[owner];\n    }\n\n    function _mint(address to, uint value) internal {\n        _totalSupply += value;\n        _balances[to] += value;\n\n        emit Transfer(address(0), to, value);\n        core.emitTransfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        uint accountBalance = _balances[from];\n        require(accountBalance >= value, \"EXCEED_AMOUNT\");\n        unchecked {\n            _balances[from] = accountBalance - value;\n        }\n        _totalSupply -= value;\n\n        emit Transfer(from, address(0), value);\n        core.emitTransfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        uint fromBalance = _balances[from];\n        require(fromBalance >= value, \"EXCEED_BALANCE\");\n\n        unchecked {\n            _balances[from] = fromBalance - value;\n        }\n        _balances[to] += value;\n\n        emit Transfer(from, to, value);\n        core.emitTransfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) public override virtual returns (bool) {\n        require(spender != address(0), \"ZERO_ADDRESS\");\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) public override virtual returns (bool) {\n        require(to != address(0), \"ZERO_ADDRESS\");\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) public override virtual returns (bool) {\n        require(from != address(0) && to != address(0), \"ZERO_ADDRESS\");\n        uint allowed = _allowances[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint).max) {\n            require(allowed >= value, \"INSUFFICIENT_ALLOWANCE\");\n            unchecked {\n                _allowances[from][msg.sender] = allowed - value;\n            }\n        }\n\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) public virtual {\n        require(owner != address(0) && spender != address(0), \"ZERO_ADDRESS\");\n        require(deadline >= block.timestamp, 'EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                _DOMAIN_SEPARATOR,\n                keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n\ncontract SatoshiSwapPair is ISatoshiSwapPair, SatoshiSwapERC20 {\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n    uint public decimals0;\n    uint public decimals1;\n\n    uint private unlocked;\n    bool private initialized;\n    ISatoshiSwapCore private core;\n    address private vaultController;\n\n    modifier lock() {\n        require(unlocked == 1, 'LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, 'Not factory');\n        _;\n    }\n\n    modifier onlyCore() {\n        require(msg.sender == address(core), 'Not core');\n        _;\n    }\n\n    function price0CumulativeLast() external override view returns (uint) {\n        (uint price0, ) = core.getCumulativePrice(address(this));\n        return price0;\n    }\n\n    function price1CumulativeLast() external override view returns (uint) {\n        (, uint price1) = core.getCumulativePrice(address(this));\n        return price1;\n    }\n\n    function kLast() external override view returns (uint) {\n        return core.getKlast(address(this));\n    }\n\n    function getReserves() external override view returns (uint112, uint112, uint32) {\n        return core.getReserves(address(this));\n    }\n\n    function getPairInfo() external override view returns (\n        ISatoshiSwapCore.PairType pairType,\n        address tokenA,\n        address tokenB,\n        uint feePoint,\n        uint tokenAfee,\n        uint tokenBfee,\n        uint decimalsA,\n        uint decimalsB,\n        uint112 reserveA,\n        uint112 reserveB,\n        uint blockTimestampLast\n    ) {\n        pairType = core.getPairType(address(this));\n        (tokenA, tokenB) = (token0, token1);\n        (feePoint, tokenAfee, tokenBfee) = core.getFees(address(this));\n        (decimalsA, decimalsB) = (decimals0, decimals1);\n        (reserveA, reserveB, blockTimestampLast) = core.getReserves(address(this));\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _core, address _token0, address _token1) external override {\n        require(!initialized, 'FORBIDDEN'); // sufficient check\n        updateDomainSeparator();\n        initialized = true;\n        unlocked = 1;\n        factory = msg.sender;\n        core = ISatoshiSwapCore(_core);\n        setCoreInternal(ISatoshiSwapCore(core));\n        (token0, token1) = (_token0, _token1);\n        decimals0 = 10 ** IERC20(_token0).decimals();\n        decimals1 = 10 ** IERC20(_token1).decimals();\n        IERC20(_token0).approve(_core, type(uint).max);\n        IERC20(_token1).approve(_core, type(uint).max);\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update() private {\n        (uint112 reserve0, uint112 reserve1, ) = core.getReserves(address(this));\n        emit Sync(reserve0, reserve1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external override lock returns (uint liquidity) {\n        uint _totalSupply = totalSupply();\n        (uint _liquidity, uint amount0, uint amount1) = core.mint(_totalSupply);\n        if (_totalSupply == 0) {\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        }\n        liquidity = _liquidity;\n        _mint(to, _liquidity);\n        _update();\n        emit Mint(msg.sender, amount0, amount1);\n        core.emitMint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external override lock returns (uint amount0, uint amount1) {\n        uint liquidity = balanceOf(address(this));\n        (amount0, amount1) = core.burn(to, liquidity, totalSupply());\n        _burn(address(this), liquidity);\n        _update();\n        emit Burn(msg.sender, amount0, amount1, to);\n        core.emitBurn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint amount0In, uint amount1In) = core.swap(msg.sender, amount0Out, amount1Out, to, data);\n        _update();\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n        core.emitSwap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external override lock {\n        core.skim(address(this), to);\n    }\n\n    // force reserves to match balances\n    function sync() external override lock {\n        core.sync(address(this));\n        _update();\n    }\n\n    /**\n     * @dev Call function from core contract\n     */\n    function checkVault(address _vaultController) external onlyCore {\n        if (vaultController != _vaultController) {\n            if (vaultController != address(0)) {\n                IERC20(token0).approve(vaultController, 0);\n                IERC20(token1).approve(vaultController, 0);\n            }\n            vaultController = _vaultController;\n            if (_vaultController != address(0)) {\n                IERC20(token0).approve(_vaultController, type(uint).max);\n                IERC20(token1).approve(_vaultController, type(uint).max);\n            }\n        }\n    }\n\n    /**\n     * @dev Approve core manually when total trades exceed the type(uint256).max\n     */\n    function approveCore() external {\n        IERC20(token0).approve(address(core), type(uint).max);\n        IERC20(token1).approve(address(core), type(uint).max);\n    }\n\n    /**\n     * @dev Override inhereted ERC20 functions\n     */\n    function name() public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (string memory) {\n        return super.name();\n    }\n\n    function symbol() public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (string memory) {\n        return super.symbol();\n    }\n\n    function decimals() public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (uint8) {\n        return super.decimals();\n    }\n\n    function totalSupply() public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (uint) {\n        return super.totalSupply();\n    }\n\n    function balanceOf(address account) public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (uint) {\n        return super.balanceOf(account);\n    }\n\n    function allowance(address owner, address spender) public view override(ISatoshiSwapPair, SatoshiSwapERC20) returns (uint) {\n        return super.allowance(owner, spender);\n    }\n\n    function approve(address spender, uint value) public override(ISatoshiSwapPair, SatoshiSwapERC20) returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function transfer(address to, uint value) public override(ISatoshiSwapPair, SatoshiSwapERC20) returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint value) public override(ISatoshiSwapPair, SatoshiSwapERC20) returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function nonces(address owner) public override(ISatoshiSwapPair, SatoshiSwapERC20) view returns (uint) {\n        return super.nonces(owner);\n    }\n\n    function DOMAIN_SEPARATOR() external override view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function PERMIT_TYPEHASH() external override pure returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) public override(ISatoshiSwapPair, SatoshiSwapERC20) {\n        return super.permit(owner, spender, value, deadline, v, r, s);\n    }\n}\n\ncontract SatoshiSwapFactory is ISatoshiSwapFactory {\n    bytes32 private constant _INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(SatoshiSwapPair).creationCode));\n\n    address public override feeToSetter;\n    ISatoshiSwapCore private core;\n    bool private initialized;\n\n    mapping(address => bool) public override isPair;\n    mapping(address => mapping(address => address)) public override getPair;\n    address[] public override allPairs;\n\n    function initialize(address _core, address _feeToSetter) external override {\n        require(!initialized, \"FORBIDDEN\");\n        initialized = true;\n        core = ISatoshiSwapCore(_core);\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external override view returns (uint) {\n        return allPairs.length;\n    }\n\n    /// @dev Read only function to make it compatible with UniswapV2 factory\n    function feeTo() external override view returns (address) {\n        return feeToSetter;\n    }\n\n    function INIT_CODE_PAIR_HASH() external override pure returns (bytes32) {\n        return _INIT_CODE_PAIR_HASH;\n    }\n\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(SatoshiSwapPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        ISatoshiSwapPair(pair).initialize(address(core), token0, token1);\n        core.initPair(pair, token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        isPair[pair] = true;\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeToSetter(address _feeToSetter) external override {\n        require(msg.sender == feeToSetter, 'FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }\n\n    function transfer(address _token) external {\n        require(msg.sender == feeToSetter, 'FORBIDDEN');\n        uint bal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).transfer(msg.sender, bal);\n    }\n}","ABI":"[{\"inputs\":[{\"indexed\":true,\"name\":\"token0\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token1\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"bytes32\",\"type\":\"bytes32\"}],\"inputs\":[],\"name\":\"INIT_CODE_PAIR_HASH\",\"stateMutability\":\"pure\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[],\"name\":\"allPairsLength\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[{\"name\":\"tokenA\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"tokenB\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"createPair\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"feeTo\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"feeToSetter\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getPair\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_core\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_feeToSetter\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"initialize\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"bool\",\"type\":\"bool\"}],\"inputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"isPair\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_feeToSetter\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_token\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"transfer\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SatoshiSwapFactory","CompilerVersion":"v0.8.19+commit.7dd6d404","OptimizationUsed":"1","Runs":"","ConstructorArguments":null,"EVMVersion":"Default","Library":null,"LicenseType":"MIT","Proxy":"0","Implementation":null,"SwarmSource":null}],"message":"OK"}