{"status":"1","result":[{"SourceCode":"// SPDX-License-Identifier: MIXED\n\n// File contracts/AMM/ISatoshiSwapCore.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapCore {\n    /**\n     * @notice Type of pair\n     * @dev currently supported: Volatile, Stable\n     * @dev Volatile: Uniswap V2 style pair that supports x * y >= k\n     * @dev Stable: Solidly style stableswap pair using x3y + y3x >= k\n     */\n    enum PairType {\n        Volatile,\n        Stable\n    }\n\n    event Initialized(address factory, address WETH, address stable, address ethStablePair);\n    event NewToken(address token, string name, string symbol, uint decimals);\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    event Mint(address indexed pair, address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed pair, address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed pair,\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event TransferLP(address indexed pair, address indexed from, address indexed to, uint value);\n    event Sync(\n        address indexed pair,\n        uint112 reserve0,\n        uint112 reserve1,\n        uint price0,\n        uint price1,\n        uint price0Eth,\n        uint price1Eth,\n        uint ethPrice\n    );\n    event UpdatePairType(address indexed pair, PairType indexed pairType);\n    event UpdateFeePoint(uint indexed feePoint);\n    event UpdateTokenFeePoint(address indexed pairAddress, address indexed tokenAddress, uint indexed feePoint);\n    event UpdateStable(address indexed stable);\n\n    /**\n     * @dev Initialize contract\n     */\n    function initialize(address _factory, address _router, address _feeToSetter, address _WETH, address _stable, bool _init) external;\n\n    /**\n     * @dev Storage view function\n     */\n    /// @dev Swap factory address (creates LP pair token)\n    function factory() external view returns (address factoryAddress);\n    /// @dev Fee controller & core controller address\n    function feeToSetter() external view returns (address feeToSetter);\n    /// @dev Vault controller address\n    function vaultController() external view returns (address vaultController);\n    /// @dev WETH contract address\n    function WETH() external view returns (address WETH);\n    /// @dev Stable token contract address (used for price view)\n    function Stable() external view returns (address stable);\n\n    /// @dev ethPrice (WETH quoted by stable)\n    function ethPrice() external view returns (uint ethPrice);\n    /// @dev ethStablePair to get the ethPrice from\n    function ethStablePair() external view returns (address ethStablePair);\n    /// @dev Fee point in Basis Points\n    function feePoint() external view returns (uint feePoint);\n\n    /**\n     * @dev Functions only called by Factory\n     */\n    /// @dev Push new pair info to SatoshiSwapCore contract\n    function initPair(address _pair, address _token0, address _token1) external;\n\n    /**\n     * @dev (Write-only) Functions only called by Pair\n     */\n    /// @dev mint function called by pair contract\n    function mint(uint totalSupply) external returns (uint liquidity, uint amount0, uint amount1);\n    /// @dev Emit mint event for core contract\n    function emitMint(address msgSender, uint amount0, uint amount1) external;\n    /// @dev burn function called by pair contract\n    function burn(address to, uint liquidity, uint totalSupply) external returns (uint amount0, uint amount1);\n    /// @dev Emit burn event for core contract\n    function emitBurn(address msgSender, uint amount0, uint amount1, address to) external;\n    /// @dev swap function called by pair contract\n    function swap(address msgSender, uint amount0Out, uint amount1Out, address to, bytes calldata data) external returns (uint amount0In, uint amount1In);\n    /// @dev Emit swap event for core contract\n    function emitSwap(address sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address to) external;\n    /// @dev Emit LP token transfer event for syncing subgraph\n    function emitTransfer(address from, address to, uint value) external;\n    /// @dev skim function called by pair contract\n    function skim(address pairAddress, address to) external;\n    /// @dev sync function called by pair contract\n    function sync(address pairAddress) external;\n\n    /**\n     * @dev (Read-only) Functions only called by Pair\n     */\n    /// @dev get pair fees\n    function getFees(address pairAddress) external view returns (uint feePoint, uint token0fee, uint token1fee);\n    /// @dev Get type of pair\n    function getPairType(address pairAddress) external view returns (PairType);\n\n    /**\n     * @dev Functions commonly called by Pair & Router\n     */\n    /// @dev fetches cumulative price\n    function getCumulativePrice(address pairAddress) external view returns (uint price0CumulativeLast, uint price1CumulativeLast);\n    /// @dev get kLast\n    function getKlast(address pairAddress) external view returns (uint kLast);\n    /// @dev fetches and sorts the reserves for a pair\n    function getReserves(address pairAddress) external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    /**\n     * @dev Functions called by Router\n     */\n    /// @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint);\n    /// @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, address tokenIn, address tokenOut) external view returns (uint);\n    /// @dev performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    /// @dev performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n\n    /**\n     * @dev View only functions\n     */\n    /// @dev Get pair address\n    function getPair(address tokenA, address tokenB) external view returns (address pairAddress);\n    /// @dev Get pair info\n    function getPairTokens(address pairAddress) external view returns (address token0, address token1);\n    /// @dev Get length of pair in storage\n    function getPairLength() external view returns (uint);\n    /// @dev Get encoded rates multiplied by 1e18\n    function getEncodedRates(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get effective rates of the pair\n    function getEffectiveRates(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get static effective price of the pair\n    function getEffectivePrices(address baseToken, address quoteToken) external view returns (uint);\n    /// @dev Get static prices of the pair\n    function getPairPrices(address pairAddress) external view returns (uint price0, uint price1, uint price0Eth, uint price1Eth);\n    /// @dev Get every tracking tokens registered\n    function getTracking() external view returns (address[] memory);\n    /// @dev Get every blacklisted pairs registered\n    function getBlacklisted() external view returns (address[] memory);\n}\n\n// File contracts/AMM/ISatoshiSwapPair.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapPair {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function getPairInfo() external view returns (\n        ISatoshiSwapCore.PairType pairType,\n        address tokenA,\n        address tokenB,\n        uint feePoint,\n        uint tokenAfee,\n        uint tokenBfee,\n        uint decimalsA,\n        uint decimalsB,\n        uint112 reserveA,\n        uint112 reserveB,\n        uint blockTimestampLast\n    );\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address _core, address _token0, address _token1) external;\n    function checkVault(address _vaultController) external;\n}\n\n// File contracts/AMM/ISatoshiSwapFactory.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface ISatoshiSwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function INIT_CODE_PAIR_HASH() external pure returns (bytes32);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function isPair(address) external view returns (bool);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function initialize(address _core, address _feeToSetter) external;\n    function setFeeToSetter(address) external;\n}\n\n// File contracts/AMM/SatoshiSwapCore.sol\n// License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface ISatoshiSwapCallee {\n    function satoshiSwapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\ninterface IController {\n    function depositPair(address, address, uint) external;\n    function withdrawAll(address, address) external;\n}\n\n// a library for performing various math operations\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    /// @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\n    function sqrt(uint x) internal pure returns (uint z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\ninterface ISatoshiSwapRouter {\n    function initialize(address _factory, address _core, address _WETH) external;\n}\n\n/// @title Core implementation of SatoshiSwap Dex Protocol\n/// @notice Will work as a calculator and a storage for pairs\n/// @dev Pairs are now being used for token vault purpose only\n/// @dev Routers will call this price to get the best routes with lower gas usage\ncontract SatoshiSwapCore is ISatoshiSwapCore {\n    using SafeTransferLib for address;\n    using SafeTransferLib for IERC20;\n    using UQ112x112 for uint224;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint private constant MAX_FEE_POINT = 1100;\n    uint private constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    bytes32 private INIT_CODE_PAIR_HASH;\n\n    address public override factory;\n    address public override feeToSetter;\n    address public override vaultController;\n\n    address public override WETH;\n    address public override Stable;\n\n    // WETH price per Stable token\n    uint public override ethPrice;\n    // ethStablePair to get the ethPrice from\n    address public override ethStablePair;\n\n    uint public override feePoint;\n\n    uint private unlocked;\n    bool private initialized;\n\n    struct PairInfo {\n        PairType pairType;\n        address token0;\n        address token1;\n    }\n\n    struct PairReserve {\n        uint112 reserve0;\n        uint112 reserve1;\n        uint32 blockTimestampLast;\n    }\n\n    struct PairDebt {\n        uint stakedDebt0;\n        uint stakedDebt1;\n    }\n\n    struct PairFees {\n        uint token0fee;\n        uint token1fee;\n    }\n\n    struct PairPrices {\n        uint price0;\n        uint price1;\n    }\n\n    struct PairEffectivePrices {\n        uint price0Effective;\n        uint price1Effective;\n        uint price0Eth;\n        uint price1Eth;\n    }\n\n    struct PairOracles {\n        uint price0CumulativeLast;\n        uint price1CumulativeLast;\n        uint kLast;\n    }\n\n    EnumerableSet.AddressSet private allPairs;\n    EnumerableSet.AddressSet private allTokens;\n    mapping(address => PairInfo) private pairInfos;\n    mapping(address => PairReserve) private pairReserves;\n    mapping(address => PairDebt) private pairDebts;\n    mapping(address => PairFees) private pairFees;\n    mapping(address => address) private pairFeeAccount;\n    mapping(address => PairPrices) private pairPrices;\n    mapping(address => PairEffectivePrices) private pairEffectivePrices;\n    mapping(address => PairOracles) private pairOracles;\n\n    /// @dev used to construct the list of all pairs we consider by default in the frontend\n    EnumerableSet.AddressSet private trackingTokens;\n    /// @dev used to filter pairs with bad liquidity\n    EnumerableSet.AddressSet private badPairs;\n    /// @dev minimum liquidity to prevent irregular rates\n    mapping(address => uint) public minimumLiq;\n    /// @dev Token decimals used for stableswap calculation\n    mapping(address => uint) private tokenDecimals;\n\n    // Using storage to avoid stack too deep error\n    uint private previousDebt0;\n    uint private previousDebt1;\n\n    modifier lock() {\n        require(unlocked == 1, 'LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, 'Not factory');\n        _;\n    }\n\n    modifier onlySetter() {\n        require(msg.sender == feeToSetter, 'Not feeToSetter');\n        _;\n    }\n\n    /// @dev Emit new token info\n    function newToken(address token) internal {\n        if (!allTokens.contains(token)) {\n            allTokens.add(token);\n            string memory name = IERC20(token).name();\n            string memory symbol = IERC20(token).symbol();\n            uint decimals = IERC20(token).decimals();\n\n            // Prevent pair creation before token is initialized\n            require(decimals != 0, \"TOKEN_INVALID\");\n            tokenDecimals[token] = 10 ** decimals;\n            emit NewToken(token, name, symbol, decimals);\n        }\n    }\n\n    /// @dev called once by the factory at time of deployment\n    function initialize(address _factory, address _router, address _feeToSetter, address _WETH, address _stable, bool _init) external override {\n        require(!initialized, 'Initialize');\n        initialized = true;\n        unlocked = 1;\n        factory = _factory;\n        feeToSetter = _feeToSetter;\n        WETH = _WETH;\n        Stable = _stable;\n        newToken(_WETH);\n        newToken(_stable);\n\n        if (_init) {\n          // Initialize factory contract\n          ISatoshiSwapFactory(_factory).initialize(address(this), _feeToSetter);\n\n          // Initialize router contract\n          ISatoshiSwapRouter(_router).initialize(_factory, address(this), _WETH);\n        }\n        \n        INIT_CODE_PAIR_HASH = ISatoshiSwapFactory(_factory).INIT_CODE_PAIR_HASH();\n\n        // Add WETH and Stable for trackingTokens by default\n        trackingTokens.add(_WETH);\n        trackingTokens.add(_stable);\n        ethStablePair = pairFor(_WETH, _stable);\n        emit Initialized(_factory, _WETH, _stable, ethStablePair);\n    }\n\n    /// @dev called once by the factory at the time of pair creation\n    function initPair(address pairAddress, address _token0, address _token1) external override onlyFactory {\n        require(initialized, 'Not initialized');\n        // First pair should be WETH / Stable pair to get the price correctly\n        if (allPairs.length() == 0) {\n            require(pairAddress == ethStablePair, \"ETH_STABLE_PAIR_REQUIRED\");\n        }\n        allPairs.add(pairAddress);\n        newToken(_token0);\n        newToken(_token1);\n        pairInfos[pairAddress] = PairInfo({\n            pairType: PairType.Volatile,\n            token0: _token0,\n            token1: _token1\n        });\n        emit PairCreated(_token0, _token1, pairAddress, allPairs.length());\n    }\n\n    /// @dev Sync effective rates to core storage\n    function updateEffectiveRates(address pairAddress) internal {\n        (address token0, address token1) = (pairInfos[pairAddress].token0, pairInfos[pairAddress].token1);\n        pairEffectivePrices[pairAddress] = PairEffectivePrices({\n            price0Effective: getEffectiveRates(token0, token1),\n            price1Effective: getEffectiveRates(token1, token0),\n            price0Eth: getEffectiveRates(token0, WETH),\n            price1Eth: getEffectiveRates(token1, WETH)\n        });\n        // Update ethPrice if the update is called from ethStablePair, should reduce gas\n        if (pairAddress == ethStablePair) {\n            ethPrice = getEffectiveRates(WETH, Stable);\n        }\n    }\n\n    /// @dev update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1, address pairAddress) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'OVERFLOW');\n        PairInfo memory pair = pairInfos[pairAddress];\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - pairReserves[pairAddress].blockTimestampLast; // overflow is desired\n        }\n        // Sync TWAP price\n        if (timeElapsed != 0 && _reserve0 != 0 && _reserve1 != 0) {\n            if (pair.pairType == PairType.Stable) {\n                if (_reserve0 > tokenDecimals[pair.token0] * 2 && _reserve1 > tokenDecimals[pair.token1] * 2) {\n                    // Using decimal balance for input amount, necessary liquidity is required\n                    unchecked {\n                        pairOracles[pairAddress].price0CumulativeLast += uint(UQ112x112.encode(uint112(_getAmountOut(tokenDecimals[pair.token0], pair.token0, pairAddress))).uqdiv(uint112(tokenDecimals[pair.token0]))) * timeElapsed;\n                        pairOracles[pairAddress].price1CumulativeLast += uint(UQ112x112.encode(uint112(_getAmountOut(tokenDecimals[pair.token1], pair.token1, pairAddress))).uqdiv(uint112(tokenDecimals[pair.token1]))) * timeElapsed;\n                    }\n                } else {\n                    // Mark price with default due to low liq\n                    unchecked {\n                        pairOracles[pairAddress].price0CumulativeLast += uint(UQ112x112.encode(uint112(tokenDecimals[pair.token1])).uqdiv(uint112(tokenDecimals[pair.token0]))) * timeElapsed;\n                        pairOracles[pairAddress].price1CumulativeLast += uint(UQ112x112.encode(uint112(tokenDecimals[pair.token0])).uqdiv(uint112(tokenDecimals[pair.token1]))) * timeElapsed;\n                    }\n                }\n            } else {\n                // * never overflows, and + overflow is desired\n                unchecked {\n                    pairOracles[pairAddress].price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n                    pairOracles[pairAddress].price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n                }\n            }\n        }\n        pairReserves[pairAddress].reserve0 = uint112(balance0);\n        pairReserves[pairAddress].reserve1 = uint112(balance1);\n        pairReserves[pairAddress].blockTimestampLast = blockTimestamp;\n\n        // Sync latest price\n        if (!badPairs.contains(pairAddress) && balance0 > minimumLiq[pair.token0] && balance1 > minimumLiq[pair.token1]) {\n            if (pair.pairType == PairType.Stable) {\n                // call getAmount only if _getAmountOut would not revert with tokenDecimals[pair.token0] input\n                if (balance0 > tokenDecimals[pair.token0] * 2 && balance1 > tokenDecimals[pair.token1] * 2) {\n                    // Using decimal balance for input amount, necessary liquidity is required\n                    unchecked {\n                        pairPrices[pairAddress].price0 = _getAmountOut(tokenDecimals[pair.token0], pair.token0, pairAddress) * 1e18 / tokenDecimals[pair.token0];\n                        pairPrices[pairAddress].price1 = _getAmountOut(tokenDecimals[pair.token1], pair.token1, pairAddress) * 1e18 / tokenDecimals[pair.token1];\n                    }\n                } else {\n                    // Mark price with default due to low liq\n                    unchecked {\n                        pairPrices[pairAddress].price0 = tokenDecimals[pair.token1] * 1e18 / tokenDecimals[pair.token0];\n                        pairPrices[pairAddress].price1 = tokenDecimals[pair.token0] * 1e18 / tokenDecimals[pair.token1];\n                    }\n                }\n            } else {\n                // * never overflows, and + overflow is desired\n                unchecked {\n                    pairPrices[pairAddress].price0 = balance1 * 1e18 / balance0;\n                    pairPrices[pairAddress].price1 = balance0 * 1e18 / balance1;\n                }\n            }\n        } else {\n            // Reset price for pairs with low liq\n            pairPrices[pairAddress].price0 = 0;\n            pairPrices[pairAddress].price1 = 0;\n        }\n\n        // Update kLast\n        if (pair.pairType == PairType.Stable) {\n            pairOracles[pairAddress].kLast = sCurve(balance0, balance1, tokenDecimals[pair.token0], tokenDecimals[pair.token1]);\n        } else {\n            pairOracles[pairAddress].kLast = balance0 * balance1;\n        }\n\n        // Sync effective rates\n        updateEffectiveRates(pairAddress);\n\n        PairEffectivePrices memory pairEffectivePrice = pairEffectivePrices[pairAddress];\n\n        emit Sync(\n            pairAddress,\n            uint112(balance0),\n            uint112(balance1),\n            pairEffectivePrice.price0Effective,\n            pairEffectivePrice.price1Effective,\n            pairEffectivePrice.price0Eth,\n            pairEffectivePrice.price1Eth,\n            ethPrice\n        );\n    }\n\n    /// @dev this low-level function should be called from a contract which performs important safety checks\n    function mint(uint totalSupply) external override lock returns (uint liquidity, uint amount0, uint amount1) {\n        address pairAddress = msg.sender;\n        require(allPairs.contains(pairAddress), 'Invalid Call');\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        (uint balance0, uint balance1) = getBalance(pairAddress, pairInfos[pairAddress].token0, pairInfos[pairAddress].token1);\n        (amount0, amount1) = (balance0 - pairReserve.reserve0, balance1 - pairReserve.reserve1);\n\n        if (totalSupply == 0) {\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n        } else {\n            liquidity = Math.min(amount0 * totalSupply / pairReserve.reserve0, amount1 * totalSupply / pairReserve.reserve1);\n        }\n\n        require(liquidity > 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n        _update(balance0, balance1, pairReserve.reserve0, pairReserve.reserve1, pairAddress);\n    }\n\n    /// @dev Emit mint event for core contract\n    function emitMint(address msgSender, uint amount0, uint amount1) external override {\n        require(allPairs.contains(msg.sender), 'Invalid Call');\n        emit Mint(msg.sender, msgSender, amount0, amount1);\n    }\n\n    /// @dev this low-level function should be called from a contract which performs important safety checks\n    function burn(address to, uint liquidity, uint totalSupply) external override lock returns (uint amount0, uint amount1) {\n        address pairAddress = msg.sender;\n        require(allPairs.contains(pairAddress), 'Invalid Call');\n        PairInfo memory pair = pairInfos[pairAddress];\n        (uint balance0, uint balance1) = getBalance(pairAddress, pair.token0, pair.token1);\n\n        amount0 = liquidity * balance0 / totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity * balance1 / totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'INSUFFICIENT_LIQUIDITY_BURNED');\n        if (pairDebts[pairAddress].stakedDebt0 > 0) checkAmount(pairAddress, pair.token0, amount0);\n        if (pairDebts[pairAddress].stakedDebt1 > 0) checkAmount(pairAddress, pair.token1, amount1);\n        previousDebt0 = 0;\n        previousDebt1 = 0;\n        IERC20(pair.token0).safeTransferFrom(pairAddress, to, amount0);\n        IERC20(pair.token1).safeTransferFrom(pairAddress, to, amount1);\n        (balance0, balance1) = getBalance(pairAddress, pair.token0, pair.token1);\n\n        _update(balance0, balance1, pairReserves[pairAddress].reserve0, pairReserves[pairAddress].reserve1, pairAddress);\n    }\n\n    /// @dev Emit burn event for core contract\n    function emitBurn(address msgSender, uint amount0, uint amount1, address to) external override {\n        require(allPairs.contains(msg.sender), 'Invalid Call');\n        emit Burn(msg.sender, msgSender, amount0, amount1, to);\n    }\n\n    /// @dev this low-level function should be called from a contract which performs important safety checks\n    function swap(address msgSender, uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock returns (uint amount0In, uint amount1In) {\n        address pairAddress = msg.sender;\n        require(allPairs.contains(pairAddress), 'Invalid Call');\n        PairInfo memory pair = pairInfos[pairAddress];\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n\n        require(amount0Out < pairReserve.reserve0 && amount1Out < pairReserve.reserve1, 'INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        require(to != pair.token0 && to != pair.token1, 'INVALID_TO');\n        if (amount0Out > 0) {\n            if (pairDebts[pairAddress].stakedDebt0 > 0) checkAmount(pairAddress, pair.token0, amount0Out);\n            IERC20(pair.token0).safeTransferFrom(pairAddress, to, amount0Out);\n        }\n        if (amount1Out > 0) {\n            if (pairDebts[pairAddress].stakedDebt1 > 0) checkAmount(pairAddress, pair.token1, amount1Out);\n            IERC20(pair.token1).safeTransferFrom(pairAddress, to, amount1Out);\n        }\n        if (data.length > 0) ISatoshiSwapCallee(to).satoshiSwapCall(msgSender, amount0Out, amount1Out, data);\n        (balance0, balance1) = getBalance(pairAddress, pair.token0, pair.token1);\n        }\n        amount0In = balance0 > pairReserve.reserve0 - amount0Out ? balance0 - (pairReserve.reserve0 - amount0Out) : 0;\n        amount1In = balance1 > pairReserve.reserve1 - amount1Out ? balance1 - (pairReserve.reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        (uint _feePoint, uint _token0fee, uint _token1fee) = getFees(pairAddress);\n        // Collect fees\n        if (amount0In > 0 && (_feePoint + _token0fee) > 0) collectFee(pairAddress, pair.token0, _feePoint, _token0fee, amount0In);\n        if (amount1In > 0 && (_feePoint + _token1fee) > 0) collectFee(pairAddress, pair.token1, _feePoint, _token1fee, amount1In);\n        // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - fee, but doing balanceOf again as safety check\n        (uint balance0Adjusted, uint balance1Adjusted) = getBalance(pairAddress, pair.token0, pair.token1);\n        require(verify(balance0Adjusted, balance1Adjusted, uint(pairReserve.reserve0), uint(pairReserve.reserve1), pairAddress), 'INSUFFICIENT_K');\n        if (previousDebt0 > 0) reDeposit(pairAddress, pair.token0, previousDebt0, balance0Adjusted);\n        if (previousDebt1 > 0) reDeposit(pairAddress, pair.token1, previousDebt1, balance1Adjusted);\n        _update(balance0Adjusted, balance1Adjusted, pairReserve.reserve0, pairReserve.reserve1, pairAddress);\n        }\n    }\n\n    /// @dev Emit swap event for core contract\n    function emitSwap(address sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address to) external override {\n        require(allPairs.contains(msg.sender), 'Invalid Call');\n        emit Swap(msg.sender, sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    /// @dev Emit LP token transfer event\n    function emitTransfer(address from, address to, uint value) external override {\n        require(allPairs.contains(msg.sender), 'Invalid Call');\n        emit TransferLP(msg.sender, from, to, value);\n    }\n\n    /// @dev force balances to match reserves\n    function skim(address pairAddress, address to) external override lock {\n        PairInfo memory pair = pairInfos[pairAddress];\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        (uint balance0, uint balance1) = getBalance(pairAddress, pair.token0, pair.token1);\n        balance0 -= pairReserve.reserve0;\n        balance1 -= pairReserve.reserve1;\n        if (balance0 != 0) IERC20(pair.token0).safeTransferFrom(pairAddress, to, balance0);\n        if (balance1 != 0) IERC20(pair.token1).safeTransferFrom(pairAddress, to, balance1);\n    }\n\n    /// @dev force reserves to match balances\n    function sync(address pairAddress) external override lock {\n        PairInfo memory pair = pairInfos[pairAddress];\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        (uint balance0, uint balance1) = getBalance(pairAddress, pair.token0, pair.token1);\n        _update(balance0, balance1, pairReserve.reserve0, pairReserve.reserve1, pairAddress);\n    }\n\n    /**\n     * @dev Vault functions to integrate BentoBox https://github.com/sushiswap/trident#bentobox-integration\n     */\n    /// @dev Get balance of pair and debt by yieldController\n    function getBalance(address pairAddress, address token0, address token1) internal view returns (uint, uint) {\n        return (\n          IERC20(token0).balanceOf(pairAddress) + pairDebts[pairAddress].stakedDebt0,\n          IERC20(token1).balanceOf(pairAddress) + pairDebts[pairAddress].stakedDebt1\n        );\n    }\n\n    /// @dev Get vault staked amount\n    function getValueDept(address pairAddress) external view returns (uint stakedDebt0, uint stakedDebt1) {\n        (stakedDebt0, stakedDebt1) = (pairDebts[pairAddress].stakedDebt0, pairDebts[pairAddress].stakedDebt1);\n    }\n\n    function depositVault(address pairAddress, address _token, uint _amount) internal {\n        ISatoshiSwapPair(pairAddress).checkVault(vaultController);\n        IController(vaultController).depositPair(pairAddress, _token, _amount);\n        if (_token == pairInfos[pairAddress].token0) {\n            pairDebts[pairAddress].stakedDebt0 += _amount;\n        } else {\n            pairDebts[pairAddress].stakedDebt1 += _amount;\n        }\n    }\n\n    function withdrawVault(address pairAddress, address _token) internal {\n        IController(vaultController).withdrawAll(_token, pairAddress);\n        if (_token == pairInfos[pairAddress].token0) {\n            pairDebts[pairAddress].stakedDebt0 = 0;\n        } else {\n            pairDebts[pairAddress].stakedDebt1 = 0;\n        }\n    }\n\n    function depositExternal(address pairAddress, uint _amount0, uint _amount1) external onlySetter {\n        depositVault(pairAddress, pairInfos[pairAddress].token0, _amount0);\n        depositVault(pairAddress, pairInfos[pairAddress].token1, _amount1);\n    }\n\n    function withdrawExternal(address pairAddress, address _token) external onlySetter {\n        withdrawVault(pairAddress, _token);\n    }\n\n    // Check the amount of token to send and withdraw from vault if it is not sufficient\n    function checkAmount(address pairAddress, address _token, uint _value) internal {\n        uint bal = IERC20(_token).balanceOf(pairAddress);\n        if (bal < _value) {\n            if (_token == pairInfos[pairAddress].token0) {\n                previousDebt0 = _value;\n            } else {\n                previousDebt1 = _value;\n            }\n            withdrawVault(pairAddress, _token);\n        }\n    }\n\n    // Redeposit to vault in case of flash swap\n    function reDeposit(address pairAddress, address _token, uint _value, uint _currentBalance) internal {\n        if (_token == pairInfos[pairAddress].token0) {\n            previousDebt0 = 0;\n        } else {\n            previousDebt1 = 0;\n        }\n        if (_currentBalance > _value) {\n            depositVault(pairAddress, _token, _value);\n        }\n    }\n\n    /**\n     * @dev Helper functions\n     */\n    /// @dev returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n    }\n\n    /// @dev calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                INIT_CODE_PAIR_HASH // init code hash\n            )))));\n    }\n\n    /// @dev Get pair address\n    function getPair(address tokenA, address tokenB) external override view returns (address pairAddress) {\n        pairAddress = pairFor(tokenA, tokenB);\n        if (!allPairs.contains(pairAddress)) {\n            pairAddress = address(0);\n        }\n    }\n\n    /// @dev Get type of pair\n    function getPairType(address pairAddress) external override view returns (PairType) {\n        return pairInfos[pairAddress].pairType;\n    }\n\n    /// @dev Get pair info\n    function getPairTokens(address pairAddress) external override view returns (address token0, address token1) {\n        return (pairInfos[pairAddress].token0, pairInfos[pairAddress].token1);\n    }\n\n    /// @dev Get length of pair in storage\n    function getPairLength() external override view returns (uint) {\n        return allPairs.length();\n    }\n\n    /// @dev Get encoded rates multiplied by 1e18\n    function getEncodedRates(address baseToken, address quoteToken) public override view returns (uint) {\n        if (baseToken == quoteToken) {\n            return 1e18;\n        }\n        address pairAddress = pairFor(baseToken, quoteToken);\n        if (!allPairs.contains(pairAddress)) {\n            return 0;\n        }\n        return pairInfos[pairAddress].token0 == baseToken ? pairPrices[pairAddress].price0 : pairPrices[pairAddress].price1;\n    }\n\n    /// @dev Get effective rates of the pair\n    function getEffectiveRates(address baseToken, address quoteToken) public override view returns (uint rate) {\n        uint trackLength = trackingTokens.length();\n        rate = getEncodedRates(baseToken, quoteToken);\n        for (uint i; i < trackLength; ++i) {\n            address trackToken = trackingTokens.at(i);\n            unchecked {\n                uint newRate = getEncodedRates(baseToken, trackToken) * getEncodedRates(trackToken, quoteToken) / 1e18;\n                if (newRate > rate) {\n                    rate = newRate;\n                }\n            }\n        }\n    }\n\n    /// @dev Get static effective price of the pair\n    function getEffectivePrices(address baseToken, address quoteToken) public override view returns (uint) {\n        if (baseToken == quoteToken) {\n            return 1e18;\n        }\n        address pairAddress = pairFor(baseToken, quoteToken);\n        if (!allPairs.contains(pairAddress)) {\n            return 0;\n        }\n        return pairInfos[pairAddress].token0 == baseToken ? pairEffectivePrices[pairAddress].price0Effective : pairEffectivePrices[pairAddress].price1Effective;\n    }\n\n    /// @dev Get static effective price of the pair\n    function getPairPrices(address pairAddress) external override view returns (uint price0, uint price1, uint price0Eth, uint price1Eth) {\n        PairEffectivePrices memory pairEffectivePrice = pairEffectivePrices[pairAddress];\n        price0 = pairEffectivePrice.price0Effective;\n        price1 = pairEffectivePrice.price1Effective;\n        price0Eth = pairEffectivePrice.price0Eth;\n        price1Eth = pairEffectivePrice.price1Eth;\n    }\n\n    /// @dev Get cumulative price multiplied by Q112\n    function getCumulativePrice(address pairAddress) external override view returns (uint price0CumulativeLast, uint price1CumulativeLast) {\n        PairOracles memory pairOracle = pairOracles[pairAddress];\n        (price0CumulativeLast, price1CumulativeLast) = (pairOracle.price0CumulativeLast, pairOracle.price1CumulativeLast);\n    }\n\n    function getTracking() external view returns (address[] memory) {\n        return trackingTokens.values();\n    }\n\n    function getBlacklisted() external view returns (address[] memory) {\n        return badPairs.values();\n    }\n\n    /// @dev Get kLast\n    function getKlast(address pairAddress) external override view returns (uint kLast) {\n        kLast = pairOracles[pairAddress].kLast;\n    }\n\n    /// @dev fetch and sort the reserves for a pair\n    /// @dev used by helper functions\n    function getReserves(address pairAddress) external override view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) {\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        (reserve0, reserve1, blockTimestampLast) = (pairReserve.reserve0, pairReserve.reserve1, pairReserve.blockTimestampLast);\n    }\n\n    function _f(uint x0, uint y) internal pure returns (uint) {\n        return x0*(y*y/1e18*y/1e18)/1e18+(x0*x0/1e18*x0/1e18)*y/1e18;\n    }\n\n    function _d(uint x0, uint y) internal pure returns (uint) {\n        return 3*x0*(y*y/1e18)/1e18+(x0*x0/1e18*x0/1e18);\n    }\n\n    /// @dev Get X or Y value from dx or dy\n    /// @dev Every param value should have at least 1e18\n    function _get_y(uint dx, uint xy, uint y) internal pure returns (uint) {\n        for (uint i = 0; i < 255; i++) {\n            uint y_prev = y;\n            uint k = _f(dx, y);\n            if (k < xy) {\n                uint dy = (xy - k)*1e18/_d(dx, y);\n                y = y + dy;\n            } else {\n                uint dy = (k - xy)*1e18/_d(dx, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    /// @dev K Curve for stable pair (x3y+y3x >= k)\n    /// @dev Note that both _x and _y should have at least 1e18\n    function sCurve(uint x, uint y, uint _decimalX, uint _decimalY) internal pure returns (uint) {\n        uint _x = x * 1e18 / _decimalX;\n        uint _y = y * 1e18 / _decimalY;\n        uint _a = (_x * _y) / 1e18;\n        uint _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n        return _a * _b / 1e18;\n    }\n\n    /// @dev Check K line\n    function verify(uint _balance0, uint _balance1, uint _reserve0, uint _reserve1, address _pairAddress) internal view returns (bool) {\n        PairInfo memory pair = pairInfos[_pairAddress];\n        if (pair.pairType == PairType.Stable) {\n            (uint decimals0, uint decimals1) = (tokenDecimals[pair.token0], tokenDecimals[pair.token1]);\n            return sCurve(_balance0, _balance1, decimals0, decimals1) >= sCurve(_reserve0, _reserve1, decimals0, decimals1);\n        } else {\n            // xy >= k\n            return _balance0 * _balance1 >= _reserve0 * _reserve1;\n        }\n    }\n\n    /// @dev Get fees for each tokens per pair\n    function getFees(address pairAddress) public override view returns (uint, uint, uint) {\n        PairFees memory pairFee = pairFees[pairAddress];\n        return (feePoint, pairFee.token0fee, pairFee.token1fee);\n    }\n\n    /// @dev Accumulate fee to core contract\n    function collectFee(address pairAddress, address _token, uint _feePoint, uint _tokenFee, uint _amount) internal {\n        if (_feePoint > 0) {\n            uint fee = (_amount * _feePoint) / 10000;\n            IERC20(_token).safeTransferFrom(pairAddress, address(this), fee);\n        }\n        if (_tokenFee > 0) {\n            uint tokenFee = (_amount * _tokenFee) / 10000;\n            address feeAccount = pairFeeAccount[pairAddress];\n            if (feeAccount == address(0)) {\n                feeAccount = address(this);\n            }\n            IERC20(_token).safeTransferFrom(pairAddress, feeAccount, tokenFee);\n        }\n    }\n\n    /// @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(uint amountIn, address tokenIn, address pairAddress) internal view returns (uint) {\n        PairInfo memory pair = pairInfos[pairAddress];\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        bool isToken0 = tokenIn == pair.token0;\n        if (isToken0) {\n            (uint _feePoint, uint inputFee,) = getFees(pairAddress);\n            amountIn -= (amountIn * (_feePoint + inputFee)) / 10000;\n        } else {\n            (uint _feePoint, , uint inputFee) = getFees(pairAddress);\n            amountIn -= (amountIn * (_feePoint + inputFee)) / 10000;\n        }\n        (uint decimalsA, uint decimalsB) = isToken0 ? (tokenDecimals[pair.token0], tokenDecimals[pair.token1]) : (tokenDecimals[pair.token1], tokenDecimals[pair.token0]);\n        (uint reserveA, uint reserveB) = isToken0 ? (uint(pairReserve.reserve0), uint(pairReserve.reserve1)) : (uint(pairReserve.reserve1), uint(pairReserve.reserve0));\n        if (pair.pairType == PairType.Stable) {\n            uint xy =  sCurve(reserveA, reserveB, decimalsA, decimalsB);\n            reserveA = reserveA * 1e18 / decimalsA;\n            reserveB = reserveB * 1e18 / decimalsB;\n            amountIn = amountIn * 1e18 / decimalsA;\n            uint y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return y * decimalsB / 1e18;\n        } else {\n            return amountIn * reserveB / (reserveA + amountIn);\n        }\n    }\n\n    /// @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function _getAmountIn(uint amountOut, address tokenIn, address pairAddress) internal view returns (uint) {\n        PairInfo memory pair = pairInfos[pairAddress];\n        PairReserve memory pairReserve = pairReserves[pairAddress];\n        bool isToken0 = tokenIn == pair.token0;\n        (uint decimalsA, uint decimalsB) = isToken0 ? (tokenDecimals[pair.token0], tokenDecimals[pair.token1]) : (tokenDecimals[pair.token1], tokenDecimals[pair.token0]);\n        (uint reserveA, uint reserveB) = isToken0 ? (uint(pairReserve.reserve0), uint(pairReserve.reserve1)) : (uint(pairReserve.reserve1), uint(pairReserve.reserve0));\n        if (pair.pairType == PairType.Stable) {\n            uint xy =  sCurve(reserveA, reserveB, decimalsA, decimalsB);\n            reserveA = reserveA * 1e18 / decimalsA;\n            reserveB = reserveB * 1e18 / decimalsB;\n            amountOut = amountOut * 1e18 / decimalsB;\n            uint x;\n            {\n            uint xd;\n            if (reserveB < amountOut) {\n                xd = amountOut - reserveB;\n            } else {\n                xd = reserveB - amountOut;\n            }\n            if (xd < 1e18) {\n                xd = 1e18;\n            }\n            x = _get_y(xd, xy, reserveA);\n            if (x < reserveA || reserveB < amountOut) {\n                x += reserveA;\n            } else {\n                x -= reserveA;\n            }\n            }\n            if (isToken0) {\n                (uint _feePoint, uint inputFee, ) = getFees(pairAddress);\n                x += (x * (_feePoint + inputFee)) / 10000;\n            } else {\n                (uint _feePoint, , uint inputFee) = getFees(pairAddress);\n                x += (x * (_feePoint + inputFee)) / 10000;\n            }\n            return x * decimalsA / 1e18;\n        } else {\n            uint _feePoint;\n            uint inputFee;\n            if (isToken0) {\n                (_feePoint, inputFee, ) = getFees(pairAddress);\n            } else {\n                (_feePoint, , inputFee) = getFees(pairAddress);\n            }\n            uint numerator = reserveA * amountOut * 10000;\n            uint denominator = (reserveB - amountOut) * (10000 - (_feePoint + inputFee));\n            return (numerator / denominator) + 1;\n        }\n    }\n\n    /// @dev given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external override view returns (uint) {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(tokenIn != address(0) && tokenOut != address(0), 'INVALID_INPUT_TOKEN');\n        return _getAmountOut(amountIn, tokenIn, pairFor(tokenIn, tokenOut));\n    }\n\n    /// @dev given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, address tokenIn, address tokenOut) external override view returns (uint) {\n        require(amountOut > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        require(tokenIn != address(0) && tokenOut != address(0), 'INVALID_INPUT_TOKEN');\n        return _getAmountIn(amountOut, tokenIn, pairFor(tokenIn, tokenOut));\n    }\n\n    /// @dev performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, address[] memory path) external override view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; ++i) {\n            amounts[i + 1] = _getAmountOut(amounts[i], path[i], pairFor(path[i], path[i + 1]));\n        }\n    }\n\n    /// @dev performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(uint amountOut, address[] memory path) external override view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            amounts[i - 1] = _getAmountIn(amounts[i], path[i - 1], pairFor(path[i], path[i - 1]));\n        }\n    }\n\n    /**\n     * @dev Restricted functions\n     */\n    function updatePairType(address _pair, PairType _pairType) external onlySetter {\n        pairInfos[_pair].pairType = _pairType;\n        emit UpdatePairType(_pair, _pairType);\n    }\n\n    function setFeePoint(uint _feePoint) external onlySetter {\n        require(_feePoint < MAX_FEE_POINT, 'Hard fee limit exceed');\n        feePoint = _feePoint;\n        emit UpdateFeePoint(_feePoint);\n    }\n\n    function setTokenFeePoint(address _pair, address _token, uint _feePoint) external onlySetter {\n        require(_feePoint < MAX_FEE_POINT, 'Hard fee limit exceed');\n        if (pairInfos[_pair].token0 == _token) {\n            pairFees[_pair].token0fee = _feePoint;\n        } else {\n            pairFees[_pair].token1fee = _feePoint;\n        }\n        emit UpdateTokenFeePoint(_pair, _token, _feePoint);\n    }\n\n    function setPairFeeAccount(address pairAddress, address feeTo) external onlySetter {\n        pairFeeAccount[pairAddress] = feeTo;\n    }\n\n    function setVaultController(address _vaultController) external onlySetter {\n        vaultController = _vaultController;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external onlySetter {\n        feeToSetter = _feeToSetter;\n    }\n\n    /// @dev Event trigger function to update stablecoin address used for LP calculation\n    function updateStableToken(address _newStable) external onlySetter {\n        Stable = _newStable;\n        newToken(_newStable);\n        emit UpdateStable(_newStable);\n    }\n\n    /**\n     * @dev Add & Remove tracking / blacklisted tokens for price view\n     */\n    function addTracking(address trackToken) external onlySetter {\n        trackingTokens.add(trackToken);\n    }\n\n    function removeTracking(address trackToken) external onlySetter {\n        trackingTokens.remove(trackToken);\n    }\n\n    function addBlacklist(address pairAddress) external onlySetter {\n        badPairs.add(pairAddress);\n    }\n\n    function removeBlacklist(address pairAddress) external onlySetter {\n        badPairs.remove(pairAddress);\n    }\n\n    function setMinimumLiq(address tokenAddress, uint _minimumLiq) external onlySetter {\n        minimumLiq[tokenAddress] = _minimumLiq;\n    }\n\n    function transfer(address _token) external onlySetter {\n        uint bal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, bal);\n    }\n}","ABI":"[{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"Burn\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":false,\"name\":\"factory\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"WETH\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stable\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethStablePair\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"Initialized\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"internalType\":\"string\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"internalType\":\"string\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"decimals\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"NewToken\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"token0\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token1\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount0In\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount1In\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount0Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount1Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"Swap\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reserve0\",\"internalType\":\"uint112\",\"type\":\"uint112\"},{\"indexed\":false,\"name\":\"reserve1\",\"internalType\":\"uint112\",\"type\":\"uint112\"},{\"indexed\":false,\"name\":\"price0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price1\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price0Eth\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price1Eth\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethPrice\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"TransferLP\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"feePoint\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"UpdateFeePoint\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pairType\",\"internalType\":\"enum ISatoshiSwapCore.PairType\",\"type\":\"uint8\"}],\"name\":\"UpdatePairType\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"stable\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"UpdateStable\",\"anonymous\":false,\"type\":\"event\"},{\"inputs\":[{\"indexed\":true,\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"feePoint\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"UpdateTokenFeePoint\",\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"Stable\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"WETH\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"addBlacklist\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"trackToken\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"addTracking\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"liquidity\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"burn\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"_amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"depositExternal\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"msgSender\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"emitBurn\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"msgSender\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"emitMint\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"sender\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"amount0In\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1In\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount0Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"emitSwap\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"from\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"value\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"emitTransfer\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[],\"name\":\"ethPrice\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"ethStablePair\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"factory\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[],\"name\":\"feePoint\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"feeToSetter\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"amountOut\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"tokenIn\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"tokenOut\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getAmountIn\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"amountIn\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"tokenIn\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"tokenOut\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"amounts\",\"internalType\":\"uint256[]\",\"type\":\"uint256[]\"}],\"inputs\":[{\"name\":\"amountOut\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"path\",\"internalType\":\"address[]\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"amounts\",\"internalType\":\"uint256[]\",\"type\":\"uint256[]\"}],\"inputs\":[{\"name\":\"amountIn\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"path\",\"internalType\":\"address[]\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address[]\",\"type\":\"address[]\"}],\"inputs\":[],\"name\":\"getBlacklisted\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"price0CumulativeLast\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"price1CumulativeLast\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getCumulativePrice\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"baseToken\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"quoteToken\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getEffectivePrices\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"rate\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"baseToken\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"quoteToken\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getEffectiveRates\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"baseToken\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"quoteToken\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getEncodedRates\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getFees\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"kLast\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getKlast\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[{\"name\":\"tokenA\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"tokenB\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getPair\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[],\"name\":\"getPairLength\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"price0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"price1\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"price0Eth\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"price1Eth\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getPairPrices\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"token0\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"token1\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getPairTokens\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"enum ISatoshiSwapCore.PairType\",\"type\":\"uint8\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getPairType\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"reserve0\",\"internalType\":\"uint112\",\"type\":\"uint112\"},{\"name\":\"reserve1\",\"internalType\":\"uint112\",\"type\":\"uint112\"},{\"name\":\"blockTimestampLast\",\"internalType\":\"uint32\",\"type\":\"uint32\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getReserves\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address[]\",\"type\":\"address[]\"}],\"inputs\":[],\"name\":\"getTracking\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"stakedDebt0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"stakedDebt1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"getValueDept\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_token0\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_token1\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"initPair\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_factory\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_router\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_feeToSetter\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_WETH\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_stable\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_init\",\"internalType\":\"bool\",\"type\":\"bool\"}],\"name\":\"initialize\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"minimumLiq\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"liquidity\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount0\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"totalSupply\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"mint\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"removeBlacklist\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"trackToken\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"removeTracking\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_feePoint\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"setFeePoint\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_feeToSetter\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"tokenAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_minimumLiq\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"setMinimumLiq\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"feeTo\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"setPairFeeAccount\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_token\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_feePoint\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"name\":\"setTokenFeePoint\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_vaultController\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"setVaultController\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"skim\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"amount0In\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1In\",\"internalType\":\"uint256\",\"type\":\"uint256\"}],\"inputs\":[{\"name\":\"msgSender\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"amount0Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"amount1Out\",\"internalType\":\"uint256\",\"type\":\"uint256\"},{\"name\":\"to\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"data\",\"internalType\":\"bytes\",\"type\":\"bytes\"}],\"name\":\"swap\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"sync\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_token\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"transfer\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_pair\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_pairType\",\"internalType\":\"enum ISatoshiSwapCore.PairType\",\"type\":\"uint8\"}],\"name\":\"updatePairType\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"_newStable\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"updateStableToken\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"outputs\":[{\"name\":\"\",\"internalType\":\"address\",\"type\":\"address\"}],\"inputs\":[],\"name\":\"vaultController\",\"stateMutability\":\"view\",\"type\":\"function\"},{\"outputs\":[],\"inputs\":[{\"name\":\"pairAddress\",\"internalType\":\"address\",\"type\":\"address\"},{\"name\":\"_token\",\"internalType\":\"address\",\"type\":\"address\"}],\"name\":\"withdrawExternal\",\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SatoshiSwapCore","CompilerVersion":"v0.8.19+commit.7dd6d404","OptimizationUsed":"1","Runs":"","ConstructorArguments":null,"EVMVersion":"Default","Library":null,"LicenseType":"MIT","Proxy":"0","Implementation":null,"SwarmSource":null}],"message":"OK"}